## 1 вопрос. Понятие об ЭВМ[](https://mai-806.github.io/fund-wiki/1sem/day9.html#1-%D0%B2%D0%BE%D0%BF%D1%80%D0%BE%D1%81-%D0%BF%D0%BE%D0%BD%D1%8F%D1%82%D0%B8%D0%B5-%D0%BE%D0%B1-%D1%8D%D0%B2%D0%BC)

Рекомендую прочесть эти статьи, чтобы были понятны последующие вопросы и термины (1-12).

- [1 ресурс](https://studfile.net/preview/4216687/page:2/)
- [2 ресурс](https://arch32.cs.msu.ru/Text/Chapter_02.pdf)
- Сравнение [двух архитектур](https://studfile.net/preview/6408636/page:16/)

**_ЭВМ_** — электронная машина **_для вычислений_**.

- Этот электронный прибор называют машиной, потому что в нём много составных частей.

**_Структурная схема:_**

![image](https://user-images.githubusercontent.com/113284506/210811694-ea629dd8-3c50-47cd-8053-5035bb44f21f.png)

- Как видно из рисунка, машина фон Неймана состоит из памяти (memory – этот термин впервые введён фон Нейманом!), устройств ввода/вывода и центрального процессора (ЦП).
- Двойными стрелками показаны потоки команд и данных, а одиночными — передача **_сигналов_** между отдельными устройствами компьютера.

---

## 2 вопрос. Принципы фон Неймана[](https://mai-806.github.io/fund-wiki/1sem/day9.html#2-%D0%B2%D0%BE%D0%BF%D1%80%D0%BE%D1%81-%D0%BF%D1%80%D0%B8%D0%BD%D1%86%D0%B8%D0%BF%D1%8B-%D1%84%D0%BE%D0%BD-%D0%BD%D0%B5%D0%B9%D0%BC%D0%B0%D0%BD%D0%B0)

Аппаратная реализация процессора фон Неймана — это машина.

**_Различают 3 принципа:_**

1) **_Принцип программного управления_**

Алгоритм работы программы представлен в виде последовательности команд.

- **_Команда_** — управляющее слово, предписывающее некоторую доступную к выполнению операцию.

2) **_Принцип адресности_**

**_Основная память_** состоит из пронумерованных ячеек, и процессору в любой момент доступна любая ячейка памяти. В этих ячейках информация хранится в виде двоичного кода. Содержимое ячейки называется **_машинным словом_**.

Архитектура узлов ЭВМ хорошо описывается с помощью булевских выражений (благодаря двоичной системе счисления).

- **_Машинное слово_** — минимальный объем данных, которым могут обмениваться между собой узлы машины.
- **_Бутылочным горлышком_** машины фон Неймана является тот факт, что за раз можно обменяться с памятью только одним машинным словом.

3) **_Принцип однородности памяти_** (или принцип хранимой в памяти команды, первый по важности!)

Память компьютера **_универсальна_**. В ней **_неразличимо друг от друга_** хранятся данные и программы. В зависимости от способа обращения к ячейке памяти одно и то же значение может использоваться и как данные, и как команда.

Время чтения и записи в любой ячейке одинаково, но два этих времени могут не совпадать.

- Сравнение [двух архитектур](https://studfile.net/preview/6408636/page:16/)

**_Канал_** — это специализированный процессор ввода/вывода. В канале есть процессор и память. Канал распараллеливает процессоры, фактически делая компьютер многопроцессорным.

---

## Вопрос 3. Структурная схема класса Mainframe.[](https://mai-806.github.io/fund-wiki/1sem/day9.html#%D0%B2%D0%BE%D0%BF%D1%80%D0%BE%D1%81-3-%D1%81%D1%82%D1%80%D1%83%D0%BA%D1%82%D1%83%D1%80%D0%BD%D0%B0%D1%8F-%D1%81%D1%85%D0%B5%D0%BC%D0%B0-%D0%BA%D0%BB%D0%B0%D1%81%D1%81%D0%B0-mainframe)

[Подробно о Mainframe](https://wiki.fenix.help/informatika/meynfreym)

- Фирма IBM — известна благодаря байтам и ASCII (придуманы там).
- В том числе известна благодаря семейству компьютеров IBM 360.

В те времена (эпоха mainframe) связь шла через телефонные линии.

- В эпоху mainframe компьютеры начали выпускать уже массово, ради денег.

---

## Вопрос 4. Открытая шинная архитектура. Системная плата.[](https://mai-806.github.io/fund-wiki/1sem/day9.html#%D0%B2%D0%BE%D0%BF%D1%80%D0%BE%D1%81-4-%D0%BE%D1%82%D0%BA%D1%80%D1%8B%D1%82%D0%B0%D1%8F-%D1%88%D0%B8%D0%BD%D0%BD%D0%B0%D1%8F-%D0%B0%D1%80%D1%85%D0%B8%D1%82%D0%B5%D0%BA%D1%82%D1%83%D1%80%D0%B0-%D1%81%D0%B8%D1%81%D1%82%D0%B5%D0%BC%D0%BD%D0%B0%D1%8F-%D0%BF%D0%BB%D0%B0%D1%82%D0%B0)

[Подробно о шине](https://studfile.net/preview/3186677/)

**_Шина компьютера_** — информационная магистраль, вокруг которой строится компьютер.

Шина — магистраль обмена данными. Это открытое устройство для соединения, аппаратного расширения, в отличие от замкнутой аппаратуры мэйнфрэймов.

Через адреса, которые есть в шине, можно обмениваться между устройствами.

Шина является к нам в форме материнской платы. Но по факту `все устройства втыкаются в шину`.

- **_Материнская плата_** — это кусок текстолита.

**_Северный и южный мосты_** — это чипы, которые обеспечивают работу материнской платы.

- `Северный мост` — работа процессора с оперативной памятью и GPU.
- `Южный мост` — медленная периферия, мелочь всякая.

До шины гибкости в компьютерах не было! Шину придумали для миникомпьютера, микропроцессора.

- При этом она была быстрой!
    
- `pdp11` — 1976 год, 16-ти разрядные мини-ЭВМ фирмы DEC.
- `Фирма DEC` — Digital Equipment Corporation, основана в 1957 году.

Лучше шинной архитектуры ничего не придумали.

> Далее вслед за DEC в эту сферу втянулась и фирма IBM со своим IBM PC, вышедшим в 1986 году.

Сначала шина была узким местом. Она начала тормозить. Тогда сделали отдельную шину процессора и отдельные шины для видеокарт.

Шине не позволили стать узким местом компьютера — поставили доп.шину и всё! Не надо менять ни программиста, ни драйвера!

---

## Вопрос 5. Процессор. Регистры. УУ и АЛУ.[](https://mai-806.github.io/fund-wiki/1sem/day9.html#%D0%B2%D0%BE%D0%BF%D1%80%D0%BE%D1%81-5-%D0%BF%D1%80%D0%BE%D1%86%D0%B5%D1%81%D1%81%D0%BE%D1%80-%D1%80%D0%B5%D0%B3%D0%B8%D1%81%D1%82%D1%80%D1%8B-%D1%83%D1%83-%D0%B8-%D0%B0%D0%BB%D1%83)

**_Процессор_** — это главная центральная обрабатывающая часть компьютера. Это **_полупроводниковый чип_** (важное замечание!), который нанесён на кристалл, работающий в соответствие с нанесённой на него схемой.

Процессор работает на **_машинном языке_** — языке команд процессора!

**_Процессор состоит из:_**

- устройства управления `(УУ)`
- арифметико-логического устройства `(АЛУ)`

**_АЛУ_** — это конкретная реализация всех программ. Процессор выполняет команды из АЛУ. Чтобы было понятнее: **_АЛУ_** — это 100 машин Тьюринга.

**_УУ_** — управляет процессом выполнения команд.

**_Регистр_** — служебная часть памяти внутри процессора.

При чтении копия машинного слова читается из ячейки памяти и записывается на регистр, а при записи копия машинного слова с регистра посылается в ячейку памяти.

РК, РАК, РД, РАД — **_лежат на ЦП_**.

**_РК_** — регистр команд, а **_РАК_** — регистр адреса команд. **_РД_** — регистр данных, а **_РАД_** — регистр адреса данных.

По принципу фон Неймана выполнение идёт команда за командой, при этом команда находится в оперативной памяти.

**_РАК_** указывает на команду в памяти и загружает команду в **_РК_** — на центральный процессор.

- **_Операнды_** идут в регистр данных.
- Команды и данные отдельно!

Вычисление адресов — непростая штука. Часто они формируются динамически. В этом процессе фигурируют регистры (их номера), где содержатся записи адресов.

- То, что вычислили, загружается на регистр данных. Получается гарвардский регистр.

Получается, что адреса регистра данных и команд лежат отдельно.

```
© мухи отдельно, котлеты отдельно
```

Чтобы данные стали командой, они должны попасть на спец.регистр. Поэтому мусор никогда не станет командой. Спец.регистр не пропустит.

- Регистры, доступные программистру — лишь арифметические!

```
© Машина фон Неймана 
- это чаша для существования вирусов.
```

РАК накручивается на длину выполненной команды. Команды выполнятся одна за другой.

Команда перехода подменяет место, где будет совершён переход.

- Посредник в чтении данных — регистр. Напрямую данные не читаются.

РАК и РК — активные данные.

И хотя программисту доступны лишь арифметические регистры, он при этом может химичить с памятью: подготовить зловредную версию программы и подменить её!

РАК, РК, РАОП, РДП — **_недоступны программисту_**.

**_Внутри процессора гарвардская архитектура_**!

> Как видно, вопросы связаны. Наша задача на экзамене — составить лаконичный рассказ, затронув смежные темы.

> - Каждый процессор внутри всегда `гарвардский`!
> - а снаружи?…..

Назначение регистра: процессор благодаря нему всегда знает, где идёт команда.

- Всё идёт через РАК и РАД `(всё идёт через регистровые адреса, так запоминаем)`
- РАК читает, РАД — читает и пишет!

Процессор выполняет свои железные, зашитые в ПЗУ команды.

```
(зашитые немками из фирмы Siemens)
```

Микропроцессор (1951) (Уилкс) — эта железка выполняет сдвиги, ссылки, но не вычисления.

- Это увеличило гибкость процессора программирования

**_Что представляют собой ядра?_**

- **_Ядра_** — это несколько аналогичных процессоров на одном кристалле, чипе.
- **_Потоки_** — это _недопроцессоры_, они позволяют распараллелить выполнение команд. При этом **_потоки имеют функцию ожидания завершения процесса_**, поэтому они неполноценны.
    
- AMD придумали контроллер памяти в процессоре (но их обвинили в воровстве у DEC).
- Intel лицензирует фирме AMD свои процессорные команды. Хотя AMD имеет немного другие команды.

**_Микропрограммная реализация_** обеспечивает гибкую настройку компьютера. За счёт неё компьютер железный (огромный, размером с комнату) упростился до уровня команд.

Микропрограммы подражают командам, разработанным на полноценном ПК.

- Универсальная машина Тьюринга — идея компьютера от Тьюринга как самостоятельной управляемой единицы.

---

## Вопросы 6-11. Архитектуры процессоров[](https://mai-806.github.io/fund-wiki/1sem/day9.html#%D0%B2%D0%BE%D0%BF%D1%80%D0%BE%D1%81%D1%8B-6-11-%D0%B0%D1%80%D1%85%D0%B8%D1%82%D0%B5%D0%BA%D1%82%D1%83%D1%80%D1%8B-%D0%BF%D1%80%D0%BE%D1%86%D0%B5%D1%81%D1%81%D0%BE%D1%80%D0%BE%D0%B2)

**_CISC_** — Complex Instruction Set Computer — компьютер с набором сложных команд.

CISC читается как **_КИСК_**, а не циск.

Зачем нужен сложный набор команд? Чтобы работать с **_железным_** железом, когда программирование было на ассемблере. (На компьютерах, прошитых нитками немецких тружениц фирмы сименс.)

- **_Цель CISC_** — обеспечить людей готовыми командами программирования для различных целей, в том числе для физики, математики.

Дальше шло усовершенствование железок. Первым, что сделали — ввели **_косвенную адресацию_**.

**_Косвенная адресация_** нужна для сокращения длины машинных команд (адрес - машинное слово). Адреса в памяти заменялись короткими номерами регистров.

1 регистр — полбайта, значит, сокращение вышло в 8 раз.

Таким образом экономилось место на ОЗУ и на самом жёстком диске.

- Прямая адресация — номер-номер. Кроме того, приплюсовывается номер регистра.
- Он же даёт + полбайта, зато происходит индексация — второе введение.

Таким образом обрабатываются массивы.

Благодаря косвенным схемам адресации вместо нескольких десятков команд получилось несколько сотен команд.

> Косвенная адресация, индексация, базирование — это ищем!

Базирование позволяет хранить и запускать программу вне зависимости от настроек команд.

Индекс образуется на лету. Это было нужно, чтобы ускорить работу пк.

- Компьютер VAX-11 (фирмы DEC) имел порядка 300 команд, это была мечта советского программиста.
- Он использовался в авиации.

> АЛУ — арифметико-логическое устройство

- [CISC](https://ru.bmstu.wiki/CISC_(Complex_Instruction_Set_Computing))

---

**_RISC_**

- В 70-ых возникла проблема: стало сложно повышать производительность ПК. Причина — сложность архитектуры CISC.
- В 1984г. было предложено убрать тупиковый CISC. Фирма IBM не любила C, Pascal, а любила свои Cobol, Fortran.

```
- А зачем нам ассемблер?
- Даже негры на нём не работают!
```

Тем более, зачем делать CISC, если на асемблере никто не работает и если есть язык C, который быстрее.

> © И на котором даже пишутся драйвера видеокарт!

Тогда предложили новую архитектуру — **_RISC_**! Уже тогда перестали экономить на памяти. Дефицит памяти пропал, и многоуровневая косвенная адресация стала не нужна. При этом программистам на асемблере платят столько же, сколько и на C, но as-шников нужно больше на один проект, что невыгодно.

> © Эра удобного вычисления полинома на асемблере уже прошла!

**_RISC_** предложена фирмой IBM. Эта архитектура разбухла в 3-4 раза в размерах программ (у нас плоская память и большой набор команд), процессор стал мощнее на порядок.

- Выигрываем в весе! А команды имели фиксированную длину!

**_Плоская память_** — от нуля и до (большого числа). **_Косвенная адресация_** режется на кусочки и кладется друг на друга.

CISC у фирмы Intel имел высокое распространение и дешивизну, но как пропихуть RISC в массы?

- Продавая CISC, в Intel понимали, что это неудобно, хоть и приносит деньги.
- Тогда они сделали в своих процессорах тайное RISC-ядро, т.е. ввели промежуточный уровень.

RISC стал внутри, на уровне микропрограмм.

1) RISC-ядро

2) II поколение RISC (64 бита)

3) RISC-32 бита — простая архитектура, используемая в роутерах.

> эту информацию стоит изучить подробнее

**_Остановимся на RISC II поколения (1991г.)_**

Это процессоры серверного типа, но на одном чипе.

> Почему на это дело ушло почти 10 лет? (вспоминаем, что только в 1984 предложили сменить CISC)

Мы говорили о плоской памяти, о том, что адресация не содержит нелинейности. В то время были 32-битные процессоры.

**_32-битный процессор_** — тот, который **_за один такт_** обрабатывает 32 бита.

Если бы компьютеры не развивались, программы были бы рыхлые (за счёт командных слов).

**_Как появились 64-битные процессоры:_**

32 бит может адресовать 2 ГБ. Адрес памяти тоже должен быть 32-битным.

> © 32-битный процессор — это `кухонный` процессор. Он нам не годится.

- [RISC](https://ru.bmstu.wiki/RISC_(Reduced_Instruction_Set_Computing))

---

**_MIPS_**

`MIPS` — Microprocessor without Interlocked Pipeline Stages (процессор R-10000).

- Процессоры MIPS были первыми RISC-процессорами на 64-битной архитектуре!
- Это процессоры серверного типа.

RISC отличается большим количеством регистров.

Придумано переименование регистров на ленту. Переименование регистров позволяет быстро переключаться в _контексте_ регистров (обмениваться).

DEC — ALPHA (64 бита). Хотели занять весь серверный рынок.

> © Процессорные фирмы не делают процессоры! Они делают деньги!

- RISC проник в CISC.
- IBM POWER PC — пример RISC 2 поколения
    
- [MIPS (1)](https://ru.bmstu.wiki/MIPS_(Microprocessor_without_Interlocked_Pipeline_Stages))
- [MIPS (2)](https://ru.wikipedia.org/wiki/MIPS_(%D0%B0%D1%80%D1%85%D0%B8%D1%82%D0%B5%D0%BA%D1%82%D1%83%D1%80%D0%B0))

---

**_VLIW_**

**_VLIW_** — Very Large Instruction Word (очень широкое командное слово).

- Intel почти примкнул к Vliw, чтобы тоже делать 64-бит.
- Но Intel вместе с Packard потерял деньги впустую.

> Поищи провалы Intel.

**_VLIW_** — это тоже попытка серверного процессора, но не вышедшая в массовом тираже.

- [VLIW (1)](https://studfile.net/preview/8556164/page:3/)
- [VLIW (2)](https://itigic.com/ru/vliw-processors-architecture-and-cpu-features/)

---

SISD — Single Instruction - Single Data.

- Не является общепринятой. 1 команда — одна единица данных.

Далеко не всегда удобно сводить к линейным системам (много памяти, большая погрешность при этом).

Когда 1 единица данных на 1 команду, линейная алгебра этого не терпит. Наша линейная алгебра хочет SIBD.

---

**_Векторно-конвейерная архитектура_**

**_Появилась векторизация_** (нужно было выяснить, как вектор представить в скалярном виде). Одна часть вектора на регистре, а другая считался в памяти.

- Векторизация считала большие данные на суперкомпьютерах (Control Delta Corporation — CDC 6600).
    
    > Моделирование ядерных взрывов, нейтронных бомб, прогнозов погоды.
    

Крей - автор идеи внутреннего распараллеливания (операнды можме загружать параллельно, одновременно).

- Параллелизм даже в последовательно написанной программе имеет место быть (например, конвейер команд!)

> Процессор Alpha имел 10 конвейеров, т.е. он в 10 раз быстрее себя одного.
> 
> - Но Intel всё равно победил в бизнесе, в итоге заработано больше денег, и они сейчас на слуху.

Конвейер распараллеливает за счёт нового/дополнительного оборудования.

- В настоящее время конвейеризация пошла в сторону thead’ов (потоков).
    
- [Векторно-конвейерная архитектура (1)](https://studfile.net/preview/6408635/page:21/)
- [Векторно-конвейерная архитектура (2)](https://studopedia.su/12_71717_vektorno-konveyernie-superkompyuteri.html)

---

**_Транспьютеры_**. Транспьютер — способ сделать вычисления из простых процессорных элементов. С помощью них брали изображение, клали в радилокационные яипы, и при помощи компьютерного зрения устанавливали точность изображения (с самолётов).

- Сейчас эти задачи осуществляются с помощью видеокарт.
    
- [Транспьютер (1)](https://ru.bmstu.wiki/%D0%A2%D1%80%D0%B0%D0%BD%D1%81%D0%BF%D1%8C%D1%8E%D1%82%D0%B5%D1%80)
- [Транспьютер (2)](https://studfile.net/preview/1047152/page:7/)

---

**_DSP_**

- [Подробно о DSP](https://studfile.net/preview/944386/)
    
- DSP — Digital Signal Processing — цифровая обработка сигналов.
    

Это переменные данные, вещественная прямая континуального характера.

Сигналы — это как переменные токи. Переменные токи дискретно преобразуются в двоичные числа, которые можно обработать процессором.

DSP — это цифровая версия аналогового компьютера. Сейчас аналоговые компьютеры сохранены на уровне приборов.

DSP нам нужны, они никуда не уйдут. Взять хотя бы слух — он у нас аналоговый, не цифровой.

- В конце любой цифровой колонки/наушников стоит аналоговая мембрана. Она контролирует процесс аудиотракта.

> © Нормальные люди никогда не пишут на железной машине ассемблера.
> 
> - Это всё равно, что есть необработанную пищу или есть бесформенную одежду.

```
© Машина фон Неймана приходит к нам в виде ЯП
```

---

## Вопрос 12. Выполнение программы ЭВМ[](https://mai-806.github.io/fund-wiki/1sem/day9.html#%D0%B2%D0%BE%D0%BF%D1%80%D0%BE%D1%81-12-%D0%B2%D1%8B%D0%BF%D0%BE%D0%BB%D0%BD%D0%B5%D0%BD%D0%B8%D0%B5-%D0%BF%D1%80%D0%BE%D0%B3%D1%80%D0%B0%D0%BC%D0%BC%D1%8B-%D1%8D%D0%B2%D0%BC)

Чтобы программа была выполнена, компьютер должен иметь её в **_основной памяти_** (или безграмотно — в **_оперативной_**).

Память называется основной, потому что она главнейшая в компьютере. В ней одновременно хранятся данные о нескольких программах, готовых к выполнению.

- **_Оперативная_** память = **_операбельная_**, а термин операбельности применим к древним железкам **_времён Адама и Евы_**.

Если машина в работоспособном состоянии, то в ней есть ОС, обрабатывающая внешние устройства.

А если компьютер выключен, то в его процессоре и в оперативной памяти ничего нет. И в момент включения нет ничего.

> Тогда нужна какая-то программа, которая всё это дело запустит!

Здесь, по аналогии со шнурком, который при натяжении развяжет ботинки **_(вспоминаем технологию бутстрепинга)_**, используется программа начальной загрузки IPL.

- `IPL` — Initial Program Load, или загрузка начальной программы.

```
© Английским владеют даже тупые англичане!
```

- Подробнее про IPL [можно прочитать здесь](https://ru.bmstu.wiki/IPL_(Initial_Program_Load))

Но мало включить компьютер. Надо подсунуть ему мелкую программу.

Если бы этого не было: надо было бы на тумблере с лампочками набрать нули и единицы, затем загрузить команду и отправить. Но это не автоматизм.

Нам нужна ОС, которая может откуда-то получать программы и автоматически выполнять их.

**_Пример выполнения программы включения:_** 1) Программа попала в пульт. Но пока что это мертвые данные.

2) ОС узнала адресочек команды. Чтобы адрес с данными **_РАД_** стал командой, надо загрузить её на **_РАК_**.

3) Процессор выполняет циклограмму (повтор итеративной программы).

4) Компьютер разменивает данные, и команда попадает на регистр команд.

5) На регистре **_УУ_** дешифрует адрес команды. Она выясняет, мусор ли это, проверяет правильность. В случае правильности дешифровка продолжается, иначе комп выдаст ошибку или остановит дешифровку.

6) У команды есть операнды, но на железе хранятся адреса.

7) Давным давно расшифровка попадала не на регистры команд, а на регистры данных.

8) УУ запускает микропрограммы, АЛУ выполняет уже то, что находится на регистре.

- Раз то, что на регистре, является копией, то эти данные не хранят в памяти. Но если мы хотим запомнить их, то введём данные вручную.
- Когда данных мало, они должны оседать на регистре (это быстрее).
- На оптимизирующих компиляторах должно быть так, как описано строчкой выше.

Пример:

C = a + b

1) Разыменовываем a

2) Разыменовываем b

3) Выполним микропрограмму сложения

4) Делаем запоминание/запись в С