## Словарик программиста:[](https://mai-806.github.io/fund-wiki/1sem/day6_2.html#%D1%81%D0%BB%D0%BE%D0%B2%D0%B0%D1%80%D0%B8%D0%BA-%D0%BF%D1%80%D0%BE%D0%B3%D1%80%D0%B0%D0%BC%D0%BC%D0%B8%D1%81%D1%82%D0%B0)
**Термины с лекции:**

- [Сборка программ на C](https://acm.bsu.by/wiki/C2017/%D0%A1%D0%B1%D0%BE%D1%80%D0%BA%D0%B0_%D0%BF%D1%80%D0%BE%D0%B3%D1%80%D0%B0%D0%BC%D0%BC_%D0%BD%D0%B0_C)
- [Библиотеки](https://blog.skillfactory.ru/glossary/biblioteka/)
- [Система программирования](https://github.com/mai-806/fund-wiki/blob/main/1sem/%D0%A1%D0%B8%D1%81%D1%82%D0%B5%D0%BC%D0%B0%20%D0%BF%D1%80%D0%BE%D0%B3%D1%80%D0%B0%D0%BC%D0%BC%D0%B8%D1%80%D0%BE%D0%B2%D0%B0%D0%BD%D0%B8%D1%8F.md)
- [Оператор](https://github.com/mai-806/fund-wiki/blob/main/1sem/%D0%9E%D0%BF%D0%B5%D1%80%D0%B0%D1%82%D0%BE%D1%80.md)
- **_Верификаторы_** могут выяснять корректность работы программы.
- **_Профилёры_** выявляют корректность и выводят данные о потреблении.
- **_Языковая среда_** — это интерпретативные компоненты ЯП (!).

---

- [Компилятор](https://github.com/mai-806/fund-wiki/blob/main/1sem/%D0%9A%D0%BE%D0%BC%D0%BF%D0%B8%D0%BB%D1%8F%D1%82%D0%BE%D1%80.md) — то же, что и **_транслятор_**!
- **_Компиляция_** — перевод текста программы с исходного формального языка на более простой язык.
- **_Компоновщик_** (линкер) связывает все объектные файлы и статические библиотеки в единый исполняемый файл, который мы и сможем запустить в дальнейшем.
- [Линкер](https://ru.bmstu.wiki/Linker_(Link_Editor))
- [Докер](https://cloud.yandex.ru/blog/posts/2022/03/docker-containers)

---

- [Интерпретатор](https://github.com/mai-806/fund-wiki/blob/main/1sem/%D0%98%D0%BD%D1%82%D0%B5%D1%80%D0%BF%D1%80%D0%B5%D1%82%D0%B0%D1%82%D0%BE%D1%80.md) — или **_отладчик_**
- [Отладка и её методы](https://github.com/mai-806/fund-wiki/blob/main/1sem/%D0%9E%D1%82%D0%BB%D0%B0%D0%B4%D0%BA%D0%B0.md)
- [Тестирование и отладка](https://github.com/mai-806/fund-wiki/blob/main/1sem/%D0%A2%D0%B5%D1%81%D1%82%D0%B8%D1%80%D0%BE%D0%B2%D0%B0%D0%BD%D0%B8%D0%B5%20%D0%B8%20%D0%BE%D1%82%D0%BB%D0%B0%D0%B4%D0%BA%D0%B0.md)

---

## Система программирования[](https://mai-806.github.io/fund-wiki/1sem/day6_2.html#%D1%81%D0%B8%D1%81%D1%82%D0%B5%D0%BC%D0%B0-%D0%BF%D1%80%D0%BE%D0%B3%D1%80%D0%B0%D0%BC%D0%BC%D0%B8%D1%80%D0%BE%D0%B2%D0%B0%D0%BD%D0%B8%D1%8F)

[Система программирования](https://github.com/mai-806/fund-wiki/blob/main/1sem/%D0%A1%D0%B8%D1%81%D1%82%D0%B5%D0%BC%D0%B0%20%D0%BF%D1%80%D0%BE%D0%B3%D1%80%D0%B0%D0%BC%D0%BC%D0%B8%D1%80%D0%BE%D0%B2%D0%B0%D0%BD%D0%B8%D1%8F.md) — организованная совокупность компонентов для обеспечения программирования.

- Главным в СП является сам язык программирования, а не компилятор.
    
- В состав СП входит языковый процессор (либо в виде интерпретатора, либо в виде компилятора)
    

> Синус, логарифм, экспонента — не компилируются в Pascal. Это хороший пример, где компилятор работает не до конца.

- Если в языке есть интерпретатор, то туда входит и языковая среда (т.е. библиотеки).
- Интерпретативная система является удобной для отладки.

_Если язык чисто компилируемый (а таких нет), то в нём и нет среды. А сама среда нужна, чтобы можно было взаимодействовать с Unix (с ОС)._

- `Верификаторы` могут выяснять корректность работы программы.
- `Профилёры` выявляют корректность и выводят данные о потреблении.

## Текстовые терминалы[](https://mai-806.github.io/fund-wiki/1sem/day6_2.html#%D1%82%D0%B5%D0%BA%D1%81%D1%82%D0%BE%D0%B2%D1%8B%D0%B5-%D1%82%D0%B5%D1%80%D0%BC%D0%B8%D0%BD%D0%B0%D0%BB%D1%8B)

**Текстовый терминал** — это последовательный компьютерный интерфейс для ввода и отображения текста. Информация в нём представлена в виде массива предварительно выбранных сформированных символов. В таких устройствах используется электронно-лучевая трубка, выдающая одноцветное изображение.

В дни универсальных ЭВМ с середины 1970-х до середины 1980-х люди использовали терминалы для дистанционной связи с компьютерами. В отличие от монитора, который обычно размещен рядом с компьютером, терминал может быть расположен очень далеко от главного компьютера.

Терминал получил своё название, так как был размещен на `терминальном конце` кабеля.

Терминал состоит из **экрана** и **клавиатуры**. Программы выполняются на главном компьютере, но результаты отображаются на экране терминала.

[Подробнее про терминал](https://studfile.net/preview/5208985/)

## Языковые процессоры[](https://mai-806.github.io/fund-wiki/1sem/day6_2.html#%D1%8F%D0%B7%D1%8B%D0%BA%D0%BE%D0%B2%D1%8B%D0%B5-%D0%BF%D1%80%D0%BE%D1%86%D0%B5%D1%81%D1%81%D0%BE%D1%80%D1%8B)

> © Assembler — это почти не нужно. Во всём мире нужно человек 100, программирующих на Assembler.

Человеку удобно работать на языке высокого уровня. Но программа и высокоуровневый язык имеют между собой большую пропасть, которую как-то надо устранять.

[**_Компилятор_**](https://github.com/mai-806/fund-wiki/blob/main/1sem/%D0%9A%D0%BE%D0%BC%D0%BF%D0%B8%D0%BB%D1%8F%D1%82%D0%BE%D1%80.md) (_или транслятор_) — принимает на вход текст высокого уровня и транслирует его в текст низкого уровня (в машинные тексты).

Раньше компиляторы было дорого и тяжело разрабатывать (да и сейчас, в принципе). Изначальным целевым языком компилятора был Assembler.

- © Unix: “Компилировать в Assembler не зазорно!”

Таким подходом оправдывалась экономия расходов на разработку новых компиляторов.

**_Компилятор_** воспринимает всю программу целиком, анализирует её правильность и переводит в машинные коды. Подобно переводчику, он берёт и выполняет письменный перевод текста.

`© Все стоят к Assembler спиной!`

Недостатки письменного перевода (компилирования): дороговизна, скорость работы. Одновременно они являются и продолжением его достоинств. Письменный перевод всегда получается качественным.

- Но при отладке нам важна скорость!

Интерпретатор же берёт и выполняет (бубнит текст).

`© Каждый отладчик - это интерпретатор!`

- Интерпретатор хорош для отладки, потому что запускает работу программы сразу (отладка — это и есть интерпретация).

[**_Интерпретатор_**](https://github.com/mai-806/fund-wiki/blob/main/1sem/%D0%98%D0%BD%D1%82%D0%B5%D1%80%D0%BF%D1%80%D0%B5%D1%82%D0%B0%D1%82%D0%BE%D1%80.md) — устный переводчик (ему говорят, и машина выполняет).

Итак, **_письменный перевод_** выполняется `компилятором`, **_устный перевод_** - `интерпретатором`.

- Си — транслятор (но в нём развита интерпретативная часть).
- Паскаль — транслятор.
- С++ — компилятор.

> © Лучший пример интерпретатора — `железный язык`.
> 
> - Он есть ещё со времён Адама и Евы…
> - Т.е. это непосредственно сам язык выполнения кода машиной.

На компиляторе пишут **многоразовые программы**

> Assembler не является интерпретатором. По методу реализации он является компилятором, хоть и очень примитивным.
> 
> - А примитивным, потому что компилирует в формате 1 к 1.

- Unix, basic — интерпретаторы.

На интерпретаторах пишут **_одноразовые программы/лабы_**.

- Lisp — интерпретатор, Марков — интерпретатор, Тьюринг — тоже.

> © Питон не предназначен для систем… © Windows по уровню сложности сравним с Boeing…

**_Отладчик_** — компилятивный суррогат.

`Языковая среда` — интерпретативные компоненты ЯП.

- Интерпретируемые языки — lisp, prolog.
    
    > © Чистых компиляторов и интерпретаторов нет.
    

`Профессор Вирт` предложил **_Pascal_** - улучшение Algol.

```
© Язык Си мощнее Pascal в 5.5 раз!
- `(joke)`
.....Почему?
- Описание страницы языка Си занимает
- 550 страниц, а языка Pascal - 99! 
```

- Pascal разрабатывали в университетах Швейцарии (при этом в то время все вузы были бедные).
- Pascal компилирует не в машинном коде и не в Assembler, а в **_p-code_**.

`P-code` — это двоичный массив, маленькая абстрактная стековая машина. Технология компилирования называлась `bootstrapping` (см. [бутстрепинг](https://github.com/mai-806/fund-wiki/blob/main/1sem/%D0%91%D1%83%D1%82%D1%81%D1%82%D1%80%D0%B5%D0%BF%D0%BF%D0%B8%D0%BD%D0%B3.md)) (в переводе - развязывание шнурка, потянув за него).

## GNU compiler collection[](https://mai-806.github.io/fund-wiki/1sem/day6_2.html#gnu-compiler-collection)

- `GCC` — это многоплатформенная и многоязычная система программирования (создана с инструментальными средствами).
    
- Lex, flex, yacc (yet another compiler compiler), Bison -
    
- [**_Cтатья_**](http://rus-linux.net/lib.php?name=/MyLDP/algol/lex-yacc-howto.html) об их применении.
    

## Компиляция программ[](https://mai-806.github.io/fund-wiki/1sem/day6_2.html#%D0%BA%D0%BE%D0%BC%D0%BF%D0%B8%D0%BB%D1%8F%D1%86%D0%B8%D1%8F-%D0%BF%D1%80%D0%BE%D0%B3%D1%80%D0%B0%D0%BC%D0%BC)

- **_Первый компилятор_** на Cи писал **_Брайан Керниган_**.
- Сам **_язык Си_** писал **_Деннис Ричи_**.
    
    > Условие компиляции — программа должна соблюдать стандарт.
    
- [**_Линкер_**](https://ru.bmstu.wiki/Linker_(Link_Editor)) — программа, производящая **_компоновку_** - связывание объектных файлов и статических библиотек в единый исполняемый файл. Он настраивает программу на готовую работу.

a.out — assembler.out (вывод ассемблера - результат линкера)

Команда _a.out_ предназначена для выполнения без затрат на компиляцию (в некомпилируемых системах).

(?) библиотеки (.dll) (?) ключи компилятора - флаги Компиляция + ключ, Linkage

## Программирование[](https://mai-806.github.io/fund-wiki/1sem/day6_2.html#%D0%BF%D1%80%D0%BE%D0%B3%D1%80%D0%B0%D0%BC%D0%BC%D0%B8%D1%80%D0%BE%D0%B2%D0%B0%D0%BD%D0%B8%D0%B5)

- [Тестирование и отладка](https://github.com/mai-806/fund-wiki/blob/main/1sem/%D0%A2%D0%B5%D1%81%D1%82%D0%B8%D1%80%D0%BE%D0%B2%D0%B0%D0%BD%D0%B8%D0%B5%20%D0%B8%20%D0%BE%D1%82%D0%BB%D0%B0%D0%B4%D0%BA%D0%B0.md)

Создание программ включает в себя ещё тестирование и отладку.

- Тесты — это данные.
- А тестирование — деятельность по доказательству отсутствия ошибок в программе. Тестирование **доказывает** отстутствие ошибок. А отладка **ищет** ошибки.

Тесты должны прощупывать **все** ветки программы.

> © Программист должен быть злым и ненавидеть свою программу, чтобы она работала!
> 
> - Т.е. он должен тщательно тестировать свою программу!

- [Оператор](https://github.com/mai-806/fund-wiki/blob/main/1sem/%D0%9E%D0%BF%D0%B5%D1%80%D0%B0%D1%82%D0%BE%D1%80.md) в программировании.

### Методы отладки:[](https://mai-806.github.io/fund-wiki/1sem/day6_2.html#%D0%BC%D0%B5%D1%82%D0%BE%D0%B4%D1%8B-%D0%BE%D1%82%D0%BB%D0%B0%D0%B4%D0%BA%D0%B8)

1) **_Ручная отладка_**. Иначе говоря, ручная прокрутка программы — это интерпретация. Она полезна! Это совершенно другой подход к программированию! 2) **_Отладка средствами стандарта языка_**. Проверки вставляем после того, как программа отказалась работать. 3) **_С помощью отладчика_**. Если тесты не работают, надо искать семантические ошибки в коде программы. Когда сами пишете программу, часто глаз замыливается, и тогда возникают ошибки. Для этого производите отладку через некоторое время, когда вы полны сил!

```
© Машина Тьюринга 
— это рулон туалетной бумаги
```

## Дополнительная информация[](https://mai-806.github.io/fund-wiki/1sem/day6_2.html#%D0%B4%D0%BE%D0%BF%D0%BE%D0%BB%D0%BD%D0%B8%D1%82%D0%B5%D0%BB%D1%8C%D0%BD%D0%B0%D1%8F-%D0%B8%D0%BD%D1%84%D0%BE%D1%80%D0%BC%D0%B0%D1%86%D0%B8%D1%8F)

- Лауреаты [премии Тьюринга](https://ru.zahn-info-portal.de/wiki/Turing_Award).
- Здесь я спросил о [колмогоровской сложности](https://github.com/mai-806/fund-wiki/blob/main/1sem/combinatorical_logic.md).
