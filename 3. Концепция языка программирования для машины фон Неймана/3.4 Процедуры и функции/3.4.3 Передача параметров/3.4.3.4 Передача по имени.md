Этот способ откладывает обработку фактических параметров до того момента, когда они действительно потребуются, то есть относится к идеям динамического связывания или динамического знакомства. Этот метод является самой мощной формой передачи параметров, одновременно наиболее опасной и неэффективной. Этот способ был введен уже в Алголе-60, развит в Алголе-68 и в некотором виде присутствует в абсолютно объектных системах программирования.

При передаче параметра по имени фактический параметр перед выполнением подпрограммы буквально (текстуально) без каких-либо предварительных вычислений его значения подставляется вместо формального параметра (реализовать такую подстановку можно на уровне внутреннего представления, передавая ссылку на внутреннее представление — дерево соответствующего выражения). 


#Вывод  Таким образом, вместо передачи значения или ссылки, в тело подпрограммы передается правило, по которому должен быть вычислен параметр.

При передаче по имени значение фактического параметра вычисляется всякий раз заново в месте и в момент использования в вызываемой подпрограмме, то есть всякий раз, когда в теле подпрограммы есть обращение к соответствующему формальному параметру. При этом значения фактических параметров вычисляются в контексте вызова, а не в контексте буквальной подстановки в теле подпрограммы.

* Если параметр — простая скалярная переменная, то вызов по имени в точности совпадает с вызовом по ссылке.
* Если параметр — выражение из скалярных переменных, то результат аналогичен вызову по значению, за исключением того, что выражение вычисляется столько раз, сколько раз используется параметр, а не один раз при входе в подпрограмму.
* Если параметр содержит элемент массива, то при вызове по имени индексы (индексные выражения!) вычисляются при каждом использовании параметра в то время как при вызове по значению или ссылке значения индексов замораживаются.

При передаче параметров по имени может случиться конфликт имен формальных и фактических параметров, который разрешается систематической заменой имен, проводимой интерпретативно средой языка при выполнении программы. Все это также усложняет транслятор, поскольку соответствующие места он должен оставлять в недотранслированном виде, подлежащем интерпретации в период выполнения программы. Поддержка процесса передачи по имени возлагается на языковую среду, роль которой существенно возрастает, увеличивая интерпретативную компоненту компилируемого языка.

При передаче по имени возможны неожиданные с примитивной точки зрения результаты. Так, вызвав процедуру:

```pascal
procedure swap(var a, b : integer {by name}); 
var t: integer; 
begin 
	t := a; 
	a := b; 
	b := t; 
end;
```

инструкцией $swap(i, x[ i ])$ получим:

``` pascal
t := i ; 
i :=x [i]; { x[i] берется от прежнего i, после чего i изменяется } 
x[i] := t; { x[i] берется от измененного i! }
```

т. е. фактический обмен в связи с изменением i произойдет с другим элементом вектора х. Желаемый эффект достигается вызовом по ссылке, при котором значения-ссылки будут заморожены.

В заключение остановимся на передаче параметров-процедур. Поскольку значением программы является её двоичное выполнимое тело, субъект, а не объект обработки данных, то передача процедур по значению-результату не имеет особого смысла.

Передача по ссылке вполне отражает парадигму передачи управления в программе по заданному адресу в машине фон Неймана. Это процедура интегрирования с подынтегральной функцией и процедура итерационного решения нелинейного уравнения, параметрами которой являются функции уравнения, разрешённого относительно х и её производной. Но самое интересное - это передача процедур по имени.

Все рассмотренные способы передачи параметров нашли применение в языках программирования. Каждый из них имеет свои достоинства и недостатки. Критериями выбора того или иного способа передачи параметров являются: 
1. Защита области данных вызывающей программы от влияния подпрограммы. 
2. Предохранение данных вызывающей программы от изменений до нормального завершения подпрограммы. 
3. Экономия памяти, выделяемой всей программе.
4. Экономия времени вычисления. 
5. Простота реализации и использования.
