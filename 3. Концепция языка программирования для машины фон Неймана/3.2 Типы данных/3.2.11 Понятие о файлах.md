**Структура файла** является обобщением понятия последовательности. Поэтому файлы прямого доступа следует считать «массивами на диске».**Компоненты файла** должны быть одного типа, и они доступны только путём последовательного прочтения. Поскольку файлы ввиду их потенциально большого размера размещаются на устройствах внешней памяти, в каждый момент времени доступна лишь текущая компонента файла, а другие компоненты могут быть получены лишь последовательным прочтением компонент файла вперёд, или, после перемотки, с начала. Движения «назад» нет ввиду инерционности электромеханических устройств.

**Характерным аппаратурным аналогом последовательного файла** является магнитная лента. В настоящее время на компьютерах устройства памяти на магнитных лентах существуют, как правило, в кассетном исполнении и практически вытеснены из массового употребления CD/DVD-устройствами. Однако в быту аудио- и видеокассеты все еще распространены и поэтому далеко ходить за соответствующими примерами нам не придется. 

#Пример Для того чтобы просмотреть второй тайм футбольного матча или середину видеофильма, необходимо просмотреть (или перемотать) первую половину кассеты.

Ввиду потенциальной бесконечности размера файлов, при их обработке следует использовать **специфические последовательные методы**, например, применять вспомогательные файлы. Это неизбежное зло не очень велико. Не следует пытаться заносить весь файл в память, помня приведенное в эпиграфе изречение. Все такие программы не будут работать на больших файлах. Таким образом, разрешается держать в памяти одну или несколько (небольшое «конечное» число) компонент файла. Запрещается помещать в память половину, четверть или любую другую долю от всегда «бесконечно» большого файла. Такой же запрет можно наложить на и хранение в памяти строки текстового файла т. к. её длина также не ограничена. 

Файлы принято подразделять на **внешние** и **внутренние**, **текстовые** и **нетекстовые, входные и выходные**.

**Внешние файлы** обычно перечисляются в заголовке программы. Они существуют до начала работы программы и/или сохраняются после окончания её работы. То есть отрезок времени их жизни шире промежутка времени работы программы. Операционная система обычно предоставляет возможность сопоставить идеальным файлам программы на языке высокого уровня реальные файлы операционной системы. Стандарт Паскаля фактически предполагает, что файл имеет простое имя и находится в текущей директории, из которой запущена программа. Поэтому процедуры инициализации и установки на начало файла rewrite и reset в стандарте Паскаля не содержат средств связи файлов Паскаль-программы с конкретными файлами используемой ОС. В различных расширениях Паскаля существуют процедуры сопоставления файлам Паскаля произвольных файлов ОС: reset со вторым параметром, open, assign, — полные имена которых задаются как строковые константы или даже переменные, и это соответствие является динамическим.

**Внутренние файлы**, также как и внешние, описываются в программе как файловые переменные. Их время жизни совпадает со временем работы программы или, в случае 186 динамического сопоставления физических файлов, короче его. Уникальные имена физических файлов операционной системы, реализующих внутренние файлы, генерируются операционной системой по требованию среды языка. Внутренние файлы используются в качестве рабочих файлов — временной памяти практически неограниченного размера. **Текстовые файлы** представляют собой распространённый вид файлов, используемых для ввода-вывода или для хранения данных в виде, непосредственно пригодном для ввода-вывода (т. е. в форме внешних изображений, а не как внутримашинные значения). Характерным для текстовых файлов является также интерпретация символа конца строки (EOL), разбивающая файл на строки. В стандарте Паскаля доступен только сам факт обнаружения конца строки вне зависимости от его физической реализации, а не соответствующая литера использумого кода. Часто текстовые файлы бывают только входными и выходными, как, например, INPUT и OUTPUT в Паскале. В языке Паскаль для машино- системонезависимого представления текстовых файлов и их строк существуют предикаты EOF и EOLN. Они позволяют Паскаль-программисту не зависеть от конкретных представлений этих служебных кодов. Таким образом, считывание литер до конца строки текстового файла должно выглядеть так:

```pascal
while not eoln do read(ch);
		read(ch);
```

Если вместо eoln написать одно из конкретных представлений ch = chr(13), то получится зависимая от кодировки Паскаль-программа, что противоречит идеологии языка высокого уровня.

**Нетекстовые файлы** не предназначены для ввода-вывода и хранят данные непосредственно во внутримашинном представлении, которое компактно, экономит не только место на устройствах внешней памяти, но и время их передачи в оперативную память, причём экономия достигается также и потому, что не требуется перевода значений в текстовые изображения и обратно, как это делается, например, при вводе/выводе real и integer из/в файлы(ов) INPUT/OUTPUT. Эта экономия весьма значительная, поскольку для преобразования изображения в значение или значения в изображение требуется его полиномиальная интерпретация (деинтерпретация), которая даже при экономной схеме Горнера имеет линейную сложность: каждое число в позиционной системе счисления есть значение многочлена с коэффициентами, равными его цифрам, вычисленного в точке, равной основанию системы счисления. Поэтому во многих компьютерах недавнего прошлого были специальные команды десятичной арифметики для выполнения операций над изображениями десятичных чисел (BCD — binary-coded decimals — двоично-кодированные десятичные). Теперь, после того как мы ознакомились с описанием и употреблением массивов, мы можем написать соответствующую Паскаль-программу вычисления значения числа по его цифрам в произвольной системе счисления.

![[Pasted image 20241128003433.png]]
![[Pasted image 20241128003446.png]]

На самом деле при использовании **схемы Горнера** для полиномиальной интерпретации изображения числа, цифробуквы которого поступают из текстового файла, массив для хранения значения той части числа, которая уже считана, не требуется: достаточно одной переменной типа integer для накопления частичных постепенно вычисляемых значений вводимого числа. ... read(c); i := i * 10 + (ord(c) - ord(’O’)); ... Полученное таким способом числовое значение во внутреннем представлении можно выводить в десятичной системе счисления. Необходимая обратная интерпретация аккумулированного числа может быть выполнена автоматически при выводе полиморфной процедурой writein. Заметим, что для больших чисел обычной целой переменной может оказаться недостаточно.