#Замечание Использование минимального набора программных инструкций позволяет решить проблему эффективной **организации программ по управлению**.

Не менее важной проблемой является проблема **организации программ по данным**. Для организации программ по данным ещё в ранних языках программирования была введена специальная конструкция — блок. Блок является простейшей формой программной единицы, представляющей собой обособленный фрагмент программы со своим локальным контекстом.

#Пример Типичный пример объектов локального контекста — параметр цикла for или временная переменная для обмена значениями двух переменных.

Иерархически **вложенная система блоков** позволяет организовать проектирование программы по данным как иерархический процесс детализации её функций. Каждая функция детализируется в виде блока с указанием неких характерных локальных данных. Если блок оказывается длинным и сложным, то в нём организуются дополнительные блоки.

Определим блок как разновидность составной инструкции языка программирования, обозначаемую открывающей скобкой (begin, {) и закрывающей скобкой (end, }) и имеющую следующую структуру:

``` pascal
begin // Начало блока языка АЛГОЛ—60 
	<последовательность описаний>
	<последовательность инструкций> 
end // Конец блока
```

Известный нам **составной оператор Паскаля** блоком не является, так как не содержит описаний и не имеет локальных данных. Как и составной оператор, блок может быть вложенным и входить в другой, охватывающий блок. Во вложенном блоке доступны объекты охватывающего блока, если только они не экранированы омонимичными (одноименными) локальными переменными. Экранирование означает приоритет локальных объектов над глобальными и является средством разрешения конфликта имен. В то же время **локальные переменные и константы** блока недоступны в охватывающих блоках. В языках с развитой блочной и модульной структурой существуют средства явного экспорта/импорта глобальных и локальных объектов. Обычно программы, процедуры и функции представляют собой блоки, т. к. имеют описания локальных объектов.

**Локальные объекты** позволяют не заботиться об уникальности имен при написании больших программ. Более того, они защищены от несанкционированного использования или от непреднамеренной порчи в большей части программы тем, что просто не видны оттуда. Локализация области действия переменных и констант позволяет не просто разгрузить глобальный контекст от второстепенных деталей, но и оптимизируют использование памяти.

При использовании **блочной структуры** управление памятью локальных данных блоков происходит следующим образом: для каждого из блоков на время его выполнения выделяется область памяти для размещения локальных переменных и констант. Глобальные переменные и константы при этом уже размещены в области памяти охватывающего блока. После завершения выполнения блока память, отведенная под локальные переменные и константы, освобождается и может быть повторно использована, что сокращает общую потребность программы в памяти, так что она значительно меньше суммарной длины всех переменных и констант. В каждый момент времени занимается память только под данные, необходимые текущему блоку и всем его прародителям. Это можно проиллюстрировать использованием памяти при выполнении программы со следующей блочной структурой:

``` c
// Глобальный контекст описаний
const int MAX = 100; // Глобальная константа, доступна во всех блоках
int main(void) // Начало блока О
{
 int В[МАХ] ; // . . . 
 for(int i = 0; i < MAX; i++){ // Блок 1 - тело цикла for, вложенный в блок 0, г - локальный параметр цикла for для блока 1 
	 for(int j = 0; j < MAX; j++){ // Блок 2 - цикл for, вложенный в цикл for; j - его локальный параметр 
		 if(В[i] > В[j]){ // Блок 3 - проверка 
			 int t = B[i] ; // Локальная переменная для обмена значениями 
			 В [i] = B[j] ; 
			 В [j] = t ; 
		} // Конец блоков 3, 2 и 1 
	}
}
return 0; 
} // Конец блока О
```

Обратите внимание, что **вложенные блоки  заканчиваются** в порядке, текстуально обратном их описанию. При выходе из блока память, занятая локальными переменными, освобождается и все хранящиеся в них значения теряются. В некоторых языках программирования возможно сохранение локальных переменных. Так в языке Алгол-60 описателем own помечаются локальные переменные, значения которых надо сохранять между обращениями к блоку. В языке Фортран локальные переменные всегда статичны и их значения сохраняются между вызовами. В языке Си существуют два описателя для этих классов памяти: static и auto. Всякая переменная в языке Си по умолчанию имеют статус автоматической, поэтому слово auto используется крайне редко.

 **Иерархическая структура блоков программы**
![[Pasted image 20241128190911.png]]

Вложенные области данных удобно размещать в стековой памяти. Это еще одна лента машины Тьюринга. В случае, если блок содержит обращения к себе (рекурсия), то возможны такие ситуации:
![[Pasted image 20241128191057.png]]

#Замечание Без выделения памяти для локальных объектов в блоках и процедурах их рекурсивное использование невозможно: каждый вызов процедуры требует нового набора омонимичных локальных переменных.

Для того, чтобы блок стал элементом построения программы, он может быть помечен и выполняется путем перехода на эту метку:

``` c++
int х = 0; // Глобальная переменная 
int main(void) // Блок О 
{
	х = 1; // Изменение глобальной х 
	{ // Блок 1 
		int х = 1; // Локальная х 
		х = ::х; /* Присвоение локальной переменной значения омонимичной глобаль ной. Обращение к глобальной х квалифицируется символом :: */
	}
	{ // Блок 2 
	int у; { // Блок 3 
		int у = 1; // Локальная переменная 
		: :у = у; // Копирование значения переменной у блока 3 в переменную вне шнего блока 2 
		}
	}
// Отсюда у не виден! 1
} 
```
![[Pasted image 20241128191634.png]]

#Замечание Соответствующий пример для языка Паскаль возможен только для вложенных процедур.