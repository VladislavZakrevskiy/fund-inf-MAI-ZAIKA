#### 1) Понятие о программном обеспечении ЭВМ. Состав, Структура, многоуровневый иерархический характер

**Понятие программного обеспечения.  
Классификация программного обеспечения.**

**Программное обеспечение** - это совокупность программ, выполненных вычислительной системой.

 К программному обеспечению (ПО) относится также вся область деятельности по проектированию и разработке (ПО):

- технология проектирования программ (нисходящее проектирование, структурное программирование и др.)
- методы тестирования программ.
- методы доказательства правильности программ.
- анализ качества работы программ и др.

**Программное обеспечение** - неотъемлемая часть ЭВМ. Оно является логическим продолжением технических средств ЭВМ, расширяющие их возможности и сферу использования.

**Классификация программного обеспечения.**

![[clip_image001.gif]]
  
Существует три категории:

**1) Прикладные программы**, непосредственно обеспечивающие выполнение необходимых пользователям работ.

**2) Системные программы**:

- управление ресурсами ЭВМ.
- создание копий используемой информации.
- проверку работоспособности устройств компьютера.
- выдачу справочной информации о компьютере и др..

**3)** **Инструментальные программные системы**, облегчающие процесс создания новых программ для компьютера.

Более или менее определенно сложились следующие группы программного обеспечения:
- операционные системы.
- системы программирования.
- инструментальные системы.
- интегрированные пакеты.
- динамические электронные таблицы.
- системы машинной графики.
- системы управления базами данных (СУБД).
- прикладное программное обеспечение.

#### 2) Понятие об ОС

**Операционная система (ОС)** - комплекс системных и управляющих программ, предназначенных для наиболее эффективного использования всех ресурсов вычислительной системы (ВС) **Вычислительная система** - взаимосвязанная совокупность аппаратных средств вычислительной техники и программного обеспечения, предназначенная для обработки информации) и удобства работы с ней.

**Назначение ОС** - организация вычислительного процесса в вычислительной системе, рациональное распределение вычислительных ресурсов между отдельными решаемыми задачами; предоставление пользователям многочисленных сервисных средств, облегчающих процесс программирования и отладки задач. ОС в значительной степени формирует у пользователя представление о возможностях ВС, удобстве работы с ней, ее пропускной способности. Различные ОС на одних и тех же технических средствах могут предоставить пользователю различные возможности для организации вычислительного процесса или автоматизированной обработки данных.

В соответствии с условиями применения различают три режима ОС: **пакетной обработки, разделения времени и реального времени**. 
- В режиме пакетной обработки ОС последовательно выполняет собранные в пакет задания. В этом режиме пользователь не имеет контакта с ЭВМ, получая лишь результаты вычислений. 
- В режиме разделения времени ОС одновременно выполняет несколько задач, допуская обращение каждого пользователя к ЭВМ. 
- В режиме реального времени ОС обеспечивает управление объектами в соответствии с принимаемыми входными сигналами. Время отклика ЭВМ с ОС реального времени на возмущающее воздействие должно быть минимальным.

#### 3) Краткая историческая справка об ОС UNIX

**ОС Unix** была создана в 1969г. несколькими программистами Bell Labs фирмы AT&T "для себя", и работала на компьютере PDP-7. Через некоторое время большая ее часть была переписана с языка ассемблера на язык C, что дало возможность перенести ее на большое количество разных платформ. В настоящее время Unix работает на большинстве существующих архитектур, и для многих из них является основной ОС.

Дальнейшее развитие Unix, разработанного в AT&T и его производные называться System V (пятая версия), сокращенно SysV, иногда используется название "AT&T-версия Unix".

В середине семидесятых годов исходный код Unix попал в университет Беркли, где была создана своя версия Unix, получившая название "BSD Unix" (Berkeley Software Distribution).

В настоящее время большинство вариатнов Unix основаны или на SystemV, или на BSD.

![http://www.inp.nsk.su/%7Ebolkhov/teach/inpunix/01tree.gif](file:///C:/Users/zakre/AppData/Local/Packages/oice_16_974fa576_32c1d314_2b4a/AC/Temp/msohtmlclip1/01/clip_image002.gif)

Однако в последнее время предпринимаются усилия по выработке единого стандарта, и наиболее современные варианты Unix нельзя четко отнести ни к той, ни к другой ветви. В их число входят IRIX (компьютеры Silicon Graphics, пример в ИЯФ -- sky), Digital OSF/1 (компьютеры Alpha, пример в ИЯФ -- AxInp), и Linux.

В настоящее время UNIX используются в основном на [серверах](http://ru.wikipedia.org/wiki/Сервер_(аппаратное_обеспечение)), а также как встроенные системы для различного оборудования. На рынке ОС для [рабочих станций](http://ru.wikipedia.org/wiki/Рабочая_станция) и домашнего применения лидером является [Microsoft Windows](http://ru.wikipedia.org/wiki/Microsoft_Windows), UNIX занимает только второе ([Mac OS X](http://ru.wikipedia.org/wiki/Mac_OS_X)), третье ([GNU/Linux](http://ru.wikipedia.org/wiki/GNU/Linux)) и многие последующие места.

UNIX-системы имеют большую историческую важность, поскольку благодаря им распространились некоторые популярные сегодня концепции и подходы в области ОС и [программного обеспечения](http://ru.wikipedia.org/wiki/Программное_обеспечение). Также, в ходе разработки Unix-систем был создан язык [Си](http://ru.wikipedia.org/wiki/Си_(язык_программирования)).

#### 4) Особенности ОС UNIX(режим работы, инструментальные и сервисные средства, язык С, TCP/P, Internet_ и пр.)
- использование простых текстовых файлов для настройки и управления системой;
- широкое применение утилит, запускаемых в [командной строке](http://ru.wikipedia.org/wiki/Интерфейс_командной_строки);
- взаимодействие с пользователем посредством виртуального устройства — терминала;
- представление физических и виртуальных устройств и некоторых средств межпроцессового взаимодействия как [файлов](http://ru.wikipedia.org/wiki/Файл);
- использование [конвейеров]((UNIX)) из нескольких программ, каждая из которых выполняет одну задачу.
- Файловая система древовидная, чувствительная к регистру символов в именах, очень слабые ограничения на длину имён и пути.
- Нет поддержки структурированных файлов ядром ОС, на уровне системных вызовов файл есть поток байтов.
- Широкое использование текстовых файлов для хранения настроек, в отличие от двоичной базы данных настроек, как, например, в Windows.
- Широкое использование утилит обработки текста для выполнения повседневных задач под управлением скриптов.

Сетевые протоколы TCP/P
* Архитектура
* Протокольные модули
* Интерфейсы
* Адресация, DNS
* Маршрутизация, шлюзы
	* Основные службы Internet
* Почта (SMTP, POP, IMAP, UUCP)
* Передача файлов (FTP)
* Файловые серверы (NFS, SMB)
* Новостные группы (NNTP)
* Удаленные терминал и выполнение(telnet,rsh,ssh)
	* Сетевая безопасность
* Использование Firewall
* Защита inetd служб, tcpwrapper (tcpd)
* Proxy – серверы

Особая роль языка программирования С состоит в том, что он, с одной стороны, позволяет писать для UNIX-систем практически столь же эффективный код, что и языки ассемблера, а с другой, является основным средством переноса программ между UNIX-системами. Можно сказать, что С является машинно-независимым языком ассемблера для UNIX-систем. Это делает его основным средством написания эффективных и переносимых программ для этого класса вычислительных систем.

#### 5) Основы интерактивной работы в ОС UNIX. Начало и окончание сеанса. Доступ к оперативной документации

В операционной системе UNIX при наборе команд, имен файлов и каталогов, используется латинский алфавит, причем различаются заглавные и прописные буквы, т.е. команды и имена файлов должны вводится в том виде, в котором они приводятся в руководствах по UNIX [[5]](http://math.tsu.ru/cluster/other/cluster/literature.htm). Процесс общения с ОС UNIX осуществляется, в основном, при помощи клавиатуры и монитора. После входа в систему на экране можно увидеть одно из двух элементов интерфейса UNIX: командную строку или графическую оболочку.

**Командная строка** – традиционный способ общения в UNIX. Когда UNIX ожидает команду, на экране высвечивается приглашение – «$». Чтобы дать команду системе, нужно в командной строке набрать имя команды, а затем ее опции и аргументы (могут отсутствовать), разделенные пробелами. После набора ввод команды осуществляется нажатием клавиши ENTER. Команды UNIX имеют структуру
```bash
command <option(s)> <argument(s)>
```

**Опции** обычно сопровождаются знаком «минус» и модифицируют поведение команды. **Аргументы** – это обычно имена каталогов или файлов.

Заметим, что каталог пользователя находится в папке /home/user_name/ корневого каталога системы. Названия файлов в ОС UNIX имеют структуру filename.ext, например, Euler.f; myCprog.c; a1.o; document.txt.
##### НАЧАЛО СЕАНСА В СИСТЕМЕ UNIX

**Пароль**

Когда вы впервые входили в систему, вам, наверное, пришлось ввести пароль, после того как вы вели свое входное имя. Однако системный администратор может и не установить пароль для вас, в этом случае приглашение password: не появится на экране.

Ваш пароль - средство безопасности; он защищает ваши файлы от доступа других пользователей. Если ваш системный администратор не установил пароль для вас, вы должны сделать это сами. Хорошо менять свой пароль примерно раз в месяц, даже если ваша система и не требует этого от вас.

Ниже приведен список правил, которым вы должны следовать, выбирая пароль. Пароль должен:
* иметь по меньшей мере шесть символов, но значение имеют только первые восемь.
* содержать по меньшей мере две буквы
* содержать по меньшей мере одну цифру или специальный знак (не используйте символы @ и #; они относятся к уничтожающим символам).
* отличаться от входных имен пользователей, отличаться от сдвинутых входных имен и не быть входным именем набранным в обратном порядке.
* новый пароль должен отличаться от старого по меньшей мере тремя символами.

Помните, что каждый может знать ваше входное имя, но только вы должны знать свой пароль. Не выбирайте пароль, о котором можно легко догадаться. Следует избегать использования в качестве пароля имен ваших супругов и детей. Также лучше иметь цифру где-нибудь в середине пароля, а не с краю.

Введите команду **passwd** для того чтобы изменить свой пароль или набрать новый.

##### Конец сеанса

Чтобы закончить сеанс, вы должны выйти из системы. Выйти можно двумя способами. Первый способ: нажать одновременно клавишу Control и букву **d**. Это называется **control d** и обозначается в справочнике **^d** или **<CTRL/d>**. После нажатия **^d** на терминале снова появится приглашение **login**

Альтернативный метод завершения сеанса - набрать слово **exit** и нажать \<RET\> после интерактивного символа $.

Если ваш терминал соединен посредством модема, вам может понадобится отключить телефон. Замечание: простое выключение терминала не заканчивает ваш сеанс в системе!

#### 6) Команды ОС UNIX. Формат команд. Интерпретатор команд

1. Простейшие действия ls - выдать список файлов в текущем каталоге.
2. **cd \[каталог\]** - сменить текущий каталог. Если имя каталога не указывается, то текущим становится домашний каталог пользователя.
3. **cp <что_копировать> <куда_копировать>** - копировать файлы.
4. **mv <что_перемещать> <куда_перемещать>** - переместить или переименовать файл.
5. **ln -s <на_что_сделать_ссылку> <имя_ссылки>** - создать символическую ссылку.
6. **rm <файлы>** - удалить файлы.
7. **mkdir <каталог>** - создать новый каталог.
8. **rmdir <каталог>** - удалить пустой каталог.
9. **rm -r <файлы и/или каталоги> (рекурсивное удаление)** -удалить файлы или каталоги и их подкаталоги. ОСТОРОЖНЕЙ с этой командой, поскольку пока у Linux нет системы полного восстановления удаленных файлов (если вы не пользуетесь специальными программами для помещения удаленных файлов в специальный каталог, что-то вроде "корзинки" в ОС Windows).
10. **cat <имя_файла>** - вывод содержимого файла на стандартный вывод (по умолчанию - на экран).

Можно записать вводимый на экран текст с помощью следующей последовательности действий:  
**cat > <имя_файла>  
.  
.  
CTRL/d

11. **more <имя_файла>** - просмотр содержимого длинного текстового файла по страницам.

12. **less <имя_файла>** - просмотр содержимого текстового файла с возможностью вернуться к предыдущим страницам. Нажмите q, когда захотите выйти из программы. "less" - аналог команды DOS "more", хотя очень часто "less" бывает более удобной чем "more".

13. **pico <имя_файла>** - редактировать текстовый файл с помощью текстового редактора pico.
14. **lynx** -просмотр файла html или WWW ссылки с помощью текстового браузера Lynx.
15. **tar -zxvf <файл>** -распаковать архив tgz или tar.gz
16. **find <каталог>** -name имя_файла -найти файл с именем "имя файла" и отобразить результат поиска на экране. Поиск начинается с каталога <каталог>; "имя_файла" может содержать маску для поиска.
17. **pine** - хорошая текстово - ориентированная программа для чтения электронной почты.
18. **mc** - запустить программу управления файлами "Midnight Commander" (Выглядит как "Norton Commander", но по своим возможностям ближе к far).
19. **./Имя_Программы** -запустить на исполнение исполняемый файл в текущем каталоге, если текущего каталога нет в списке каталогов, указанных в переменной окружения PATH.
20. **xterm (в X терминале)** -запустить простой терминал в графической оболочке X-windows. Для того чтобы выйти из него, наберите "exit".

##### Стандартные команды и команды, дающие информацию по системе команд (всегда набираются в одной строке). Описание

1. **pwd** - вывести имя текущего каталога.
2. **whoami** - вывести имя под которым Вы зарегистрированы.
3. **date** - вывести дату и время.
4. **time <имя программы>** - выполнить программу и получить информацию о времени, нужном для ее выполнения. Не путайте эту команду с date. Например: Я могу определить выполнить команду ls и узнать, как много времени требуется для вывода списка файлов в каталоге, набрав последовательность: time ls
5. **who** - определить кто из пользователей работает на машине.
6. **rwho -a** - определение всех пользователей, подключившихся к вашей сети. Для выполнения этой команды требуется, чтобы был запущен процесс rwho.
7. **ruptime** -какие машины работают в сети, и какие остановлены.
8. **finger <имя_пользователя>** - системная информация о зарегистрированном пользователе. Попробуйте: finger <ваш login-name>
9. **uptime** - количество времени, прошедшего с последней перезагрузки операционной системы.
10. **ps a** - вывести список текущих процессов в Вашем сеансе работы.
11. **top** - интерактивный список текущих процессов, отсортированных по использованию центрального процессора.
12. **uname -a** - вывести информацию о версии операционной системы.
13. **free** - вывести информацию по использованию памяти.
14. **df -h** - вывести информацию о свободном и используемом месте на дисках.
15. **du . -bh | more** - вывод на экран информации о размере файлов и каталогов, начиная с текущего каталога.
16. **set|more** - вывести текущие значения переменных окружения. (Не для всех shell. Для csh/tcsh - printenv | more, хотя set тоже покажет полезную информацию.)
17. **echo $PATH** -вывести значение переменной окружения "PATH" Команда echo может использоваться для вывода значений любых переменных окружения. Воспользуйтесь командами set или printenv для получения полного списка.

##### Работа с сетью

1. **ssh** - обеспечивает безопасное вхождение в удаленный сеанс работы с другой машиной, а также позволяет выполнить заданную команду на удаленной машине без вхождения в сеанс работы:  
2. **ssh \[-l Ваше_имя_пользователя_на_удаленной_машине\] <имя_удаленной_машины>** -вхождение в сеанс на удаленной машине. Используйте имя машины или ее IP адрес. (Вы должны быть зарегистрированы на этой удаленной машине).  (если Ваше_имя_пользователя одинаково на локальной и удаленной машинах, то его можно не набирать, т.е.:  
3. **ssh <имя_удаленной_машины>** - позволит Вам войти в сеанс на удаленной машине)  
4. **ssh <Ваше_имя_пользователя_на удаленной машине@><имя_удаленной_машины> <команда>** - выполнит на удаленном компьютере заданную команду и передаст Вам на экран результат ее выполнения (При установлении соединения по ssh Вы должны будете ввести пароль, который Вы имеете на удаленном компьютере; при этом пароль будет передан по сети в зашифрованном виде, т.е. безопасным образом.)
5. **scp** - обеспечивает безопасное копирование файлов в сети:  
6. **scp <имя_файла_на_локальном_компьютере> <Ваше_имя_пользователя_на удаленной машине>@<имя_удаленной_машины>:** - cкопирует файл с локального компьютера в Вашу корневую директорию на удаленном компьютере (наличие ":" в конце команды обязательно).
7. **telnet <имя_удаленной_машины>** - связаться по telnet с другой машиной. Войдите в сеанс работы после установления связи с помощью вашего пароля.
8. **ftp <имя_удаленной_машины>** - связаться по ftp с удаленным компьютером. Этот тип связи хорош для копирования файлов с/на удаленную машину.

		Предпочтительно не пользоваться командами **telnet** и **ftp**, а использовать только ssh и scp, поскольку они обеспечивают безопасность сетевого соединения!!!

9. **hostname -i** - показывает IP адрес компьютера, на котором Вы работаете.

##### Некоторые команды администрирования

1. **alias ls="ls -Fskb --color"** - создать alias - псевдоним для того чтобы одной командой можно было запустить более сложную комбинацию команд. Поместите создание alias в файл /etc/bashrc если вы хотите, чтобы эти псевдонимы были доступны всем пользователям вашей системы.

**Для tcsh** - формат определения alias другой:

**alias la 'ls -AF --color=none'**

2. **kapasswd** -команда для изменения пароля для доступа к файловой системе AFS. При работе на базовом Linux-кластере ЛИТ следует пользоваться только этой командой (а не командой passwd!) для изменения пароля для вхождения в кластер.
3. **passwd** -изменить свой пароль на каком-либо локальном компьютере.

#### 7) Протоколирование команд

![](file:///C:/Users/zakre/AppData/Local/Packages/oice_16_974fa576_32c1d314_2b4a/AC/Temp/msohtmlclip1/01/clip_image004.jpg)
#### 8) Файловая система ОС UNIX (структура, наименование, навигация)

Файловая система в Unix организована в виде единого дерева директорий. Никаких букв дисков (a:, c:) здесь нет, а если используется несколько физических дисков (например, первый жесткий диск, второй, CD-ROM и т.д.) то они представляются отдельными ветвями на общем дереве.

Директории разделяются косой чертой "/" (а не обратной, как в Dos), например, "/home/inpunix/ivanov/" -- поддиректория "ivanov" в директории "inpunix" директории "home". Самая верхняя директория ("корневая") называется "/".

Какие разрешаются имена:

- Имя файла (и директории) может содержать практически любые символы, включая пробелы (и даже управляющие символы, типа перевода строки, если удастся их ввести). Примеры:

list.txt  
A file with spaces.txt  
Сводный отчет по трудозатратам за 1998й год.tex  
Manual [part 1 of 3].txt

- Символ "." не является особенным, и в имени может быть любое их количество, а может и не быть вовсе. Так, к примеру,

file.with.many.dots  
short  
file_without_extension  
являются вполне нормальными именами.

- У программ не требуется какое-либо специальное расширение, типа .exe -- достаточно установить атрибут "x" (см. ниже).
- Заглавные и маленькие буквы различаются; так,

report.txt  
REPORT.TXT  
Report.txt  
RePorT.tXt

это четыре разных имени.

- В отличие от Dos/Windows, нет зарезервированных имен, таких, как con, com1 и т.д. Вместо них есть сответствующие файлы устройств в директории /dev:

| **Файл в Dos** | **Устройство в Unix** | **Назначение**               |
| -------------- | --------------------- | ---------------------------- |
| con            | /dev/tty              | Консоль                      |
| nul            | /dev/null             | Пустота                      |
| com1           | /dev/ttyS0            | Первый последовательный порт |
| lpt1           | /dev/lp0              | Первый параллельный порт     |

- У программ не требуется какое-либо специальное расширение, типа .exe -- достаточно установить атрибут "x" (см. ниже).
- Длина имени может быть до 255 символов; полный путь (включая директории) -- 1024 символа.

Хотя единственный символ, которого не может быть в имени, это "/" (поскольку это разделитель директорий), лучше не слишком увлекаться, и стараться не делать имен с пробелами, и не злоупотреблять различием в регистре букв -- это только внесет лишнюю путаницу. Также лучше не называть файлы по-русски.

В каждой директории есть поддиректория ".", являющаяся ссылкой на саму директорию и "..", являющаяся ссылками директорию уровнем выше.

Файлы, имена которых начинаются c точки (включая . и ..), считаются "неинтересными", и в листинге директории обычно не показываются.

#### 9) Метасимволы для генерации имен файлов

**Метасимволы** - символы, имеющие специальное значение для интерпретатора :

	? * ; & ( ) | ^ < > <пробел> <табуляция> <возврат_каретки>

Однако каждый из этих символов может представлять самого себя, если перед ним стоит \\. Все символы, заключенные между кавычками ' и ', представляют самих себя. Между двойными кавычками (") выполняются подстановки команд (см п. 2.2) и параметров (см. п. 2.3), а символы \\, \`, " и $ могут экранироваться предшествующим символом \\.

После всех подстановок в каждом слове команды ищутся символы *,?, и \[. Если находится хотя бы один из них, то это слово рассматривается как шаблон имен файлов и заменяется именами файлов, удовлетворяющих данному шаблону (в алфавитном порядке). Если ни одно имя файла не удовлетворяет шаблону, то он остается неизменным. Значения указанных символов:
* \*   -   произвольная  (возможно  пустая)  последовательность символов;
* ? - один произвольный символ;
* \[...\] - любой из символов, указанных в скобках перечислением и/или с указанием диапазона;
* cat f\* - выдаст все файлы каталога, начинающиеся с "f";
* cat \*f\* - выдаст все файлы, содержащие "f";
* cat   program.?   -   выдаст   файлы   данного   каталога  с однобуквенными расширениями, скажем "program.c" и "program.o", но не выдаст "program.com";
* cat  \[a-d\]\*  -  выдаст файлы, которые начинаются с "a", "b", "c", "d". Аналогичный эффект дадут и команды "cat \[abcd\]\*" и "cat \[bdac\]\*".

#### 10) Управление файлами (создание, копирование, переименование, сцепление, удаление)

| ![urbbul1d](file:///C:/Users/zakre/AppData/Local/Packages/oice_16_974fa576_32c1d314_2b4a/AC/Temp/msohtmlclip1/01/clip_image005.gif) | file filename(s) - отображает тип файла (например ASCII текст, документ Word и др.)         |
| ----------------------------------------------------------------------------------------------------------------------------------- | ------------------------------------------------------------------------------------------- |
| ![urbbul1d](file:///C:/Users/zakre/AppData/Local/Packages/oice_16_974fa576_32c1d314_2b4a/AC/Temp/msohtmlclip1/01/clip_image005.gif) | cat filename(s) - показывает содержание файлов (используется только для текстовых файлов!); |
| ![urbbul1d](file:///C:/Users/zakre/AppData/Local/Packages/oice_16_974fa576_32c1d314_2b4a/AC/Temp/msohtmlclip1/01/clip_image005.gif) | more filename(s) - действует также, как и cat, но позволяет листовать страницы;             |
| ![urbbul1d](file:///C:/Users/zakre/AppData/Local/Packages/oice_16_974fa576_32c1d314_2b4a/AC/Temp/msohtmlclip1/01/clip_image005.gif) | head filename - показывает первые десять строк файла filename;                              |
| ![urbbul1d](file:///C:/Users/zakre/AppData/Local/Packages/oice_16_974fa576_32c1d314_2b4a/AC/Temp/msohtmlclip1/01/clip_image005.gif) | tail filename - показывает последние десять строк файла filename;                           |
| ![urbbul1d](file:///C:/Users/zakre/AppData/Local/Packages/oice_16_974fa576_32c1d314_2b4a/AC/Temp/msohtmlclip1/01/clip_image005.gif) | wc filename(s) - для каждого текстового файла показывает число байт, букв и линий;          |
| ![urbbul1d](file:///C:/Users/zakre/AppData/Local/Packages/oice_16_974fa576_32c1d314_2b4a/AC/Temp/msohtmlclip1/01/clip_image005.gif) | rm filename(s) - уничтожает файлы;                                                          |
| ![urbbul1d](file:///C:/Users/zakre/AppData/Local/Packages/oice_16_974fa576_32c1d314_2b4a/AC/Temp/msohtmlclip1/01/clip_image005.gif) | cp filename newname - создает копии файлов с новыми именами;                                |
| ![urbbul1d](file:///C:/Users/zakre/AppData/Local/Packages/oice_16_974fa576_32c1d314_2b4a/AC/Temp/msohtmlclip1/01/clip_image005.gif) | cp filename(s) dir копирует один или более файлов в другой каталог;                         |
| ![urbbul1d](file:///C:/Users/zakre/AppData/Local/Packages/oice_16_974fa576_32c1d314_2b4a/AC/Temp/msohtmlclip1/01/clip_image005.gif) | mv oldname newname - изменяет имя файла или каталога;                                       |
| ![urbbul1d](file:///C:/Users/zakre/AppData/Local/Packages/oice_16_974fa576_32c1d314_2b4a/AC/Temp/msohtmlclip1/01/clip_image005.gif) | mv filename(s) dir - перемещает один или более файлов в другой каталог;                     |
| ![urbbul1d](file:///C:/Users/zakre/AppData/Local/Packages/oice_16_974fa576_32c1d314_2b4a/AC/Temp/msohtmlclip1/01/clip_image005.gif) | find dir –name filename - пытается локализовать файл filename рекурсивно в подкаталоге dir; |

#### 11) Управление каталогами

| ![urbbul1d](file:///C:/Users/zakre/AppData/Local/Packages/oice_16_974fa576_32c1d314_2b4a/AC/Temp/msohtmlclip1/01/clip_image005.gif) | pwd – показывает текущий рабочий каталог;                                                                 |
| ----------------------------------------------------------------------------------------------------------------------------------- | --------------------------------------------------------------------------------------------------------- |
| ![urbbul1d](file:///C:/Users/zakre/AppData/Local/Packages/oice_16_974fa576_32c1d314_2b4a/AC/Temp/msohtmlclip1/01/clip_image005.gif) | cd dir – установит текущим рабочим каталогом катало с именем dir;                                         |
| ![urbbul1d](file:///C:/Users/zakre/AppData/Local/Packages/oice_16_974fa576_32c1d314_2b4a/AC/Temp/msohtmlclip1/01/clip_image005.gif) | cd – вернуться в каталог /home/user_name/;                                                                |
| ![urbbul1d](file:///C:/Users/zakre/AppData/Local/Packages/oice_16_974fa576_32c1d314_2b4a/AC/Temp/msohtmlclip1/01/clip_image005.gif) | mkdir subdir – создать новый подкаталог с именем subdir;                                                  |
| ![urbbul1d](file:///C:/Users/zakre/AppData/Local/Packages/oice_16_974fa576_32c1d314_2b4a/AC/Temp/msohtmlclip1/01/clip_image005.gif) | rmdir subdir – переместить подкаталог с именем subdir, который должен быть пустым;                        |
| ![urbbul1d](file:///C:/Users/zakre/AppData/Local/Packages/oice_16_974fa576_32c1d314_2b4a/AC/Temp/msohtmlclip1/01/clip_image005.gif) | ls – показать содержание текущего каталога;                                                               |
| ![urbbul1d](file:///C:/Users/zakre/AppData/Local/Packages/oice_16_974fa576_32c1d314_2b4a/AC/Temp/msohtmlclip1/01/clip_image005.gif) | ls dir – показать содержание каталога dir;                                                                |
| ![urbbul1d](file:///C:/Users/zakre/AppData/Local/Packages/oice_16_974fa576_32c1d314_2b4a/AC/Temp/msohtmlclip1/01/clip_image005.gif) | ls –A - показать все файлы, в том числе и скрытые;                                                        |
| ![urbbul1d](file:///C:/Users/zakre/AppData/Local/Packages/oice_16_974fa576_32c1d314_2b4a/AC/Temp/msohtmlclip1/01/clip_image005.gif) | ls –l - показать аттрибуты (владельца, разрешение на доступ, размер файла и время последней модификации); |
| ![urbbul1d](file:///C:/Users/zakre/AppData/Local/Packages/oice_16_974fa576_32c1d314_2b4a/AC/Temp/msohtmlclip1/01/clip_image005.gif) | mv oldname newname - изменить имя подкаталога или переместить его;                                        |
| ![urbbul1d](file:///C:/Users/zakre/AppData/Local/Packages/oice_16_974fa576_32c1d314_2b4a/AC/Temp/msohtmlclip1/01/clip_image005.gif) | cp dirname destination - копировать весь подкаталог dirname в другое место destination                    |

#### 12) Переадресация ввода и вывода в ОС UNIX

### Перенаправление ввода и вывода

В системе UNIX некоторые команды ожидают ввод только с клавиатуры (стандартный ввод) и большинство команд отображают свой вывод на экране терминала (стандартный вывод). Однако система UNIX позволяет вам перенаправлять ввод и вывод в файлы и программы, т.е. вы можете сказать shell:

- взять ввод из файла, а не с клавиатуры;
- послать вывод в файл, а не на терминал;
- использовать программу как исходные данные для другой программы.

#### 8.3.1. Перенаправить ввод: знак <

Чтобы перенаправить ввод, укажите в командной строке после знака "меньше чем" (<) имя файла:

       command < имя_файла<CR>

#### 8.3.2. Перенаправить вывод: знак >

Чтобы перенаправить вывод, укажите в командной строке после знака "больше чем" (>) имя файла:

       command > имя_файла<CR>

**Примечание**. Если вы перенаправите вывод в уже существующий файл, то вывод вашей команды заменит содержимое существующего файла.

Перед тем, как перенаправить вывод команды в конкретный файл убедитесь, что этот файл не существует. shell не предупреждает, что выполняет перезапись существующего файла.

Чтобы убедиться, что файл с запланированным именем не существует, воспользуйтесь командой ls с аргументом "имя_файла". Если этот файл не существует, то ls выдаст сообщение, что файл не найден в текущем справочнике. Например, проверка существования файлов temp и junk даст следующий результат:
 1. $ ls temp\<CR\>
        temp
2. $ ls junk\<CR\>
        junk: no such file or directiry

Это означает, что вы можете назвать свой файл junk, но не можете использовать в качестве имени temp, если не хотите потерять содержимое существующего файла.

#### 8.3.3. Добавить вывод в существующий файл

Чтобы добавить вывод в существующий файл и не разрушить его, вы можете воспользоваться символом >>:

       command >> имя_файла<CR>

В результате выполнения команды вывод будет добавлен в конец существующего файла. Если файл не существует, то он будет создан.

#### 13) Конвейеры команд

**Конвейер**. Взять стандартный вывод одной программы и использовать как стандартный ввод другой. Это одна из самых богатых возможностей ОС UNIX; ее можно использовать для создания собственных команд. Предположим, Вам нужен список всех файлов, принадлежащих **edk**. Эту операцию нельзя выполнить с помощью ключей команды **ls**, но, используя конвейер, можно объединить команды **ls -l** и **grep**:

% ls -ls | grep "edk"

Команда ls -l выдает список всех файлов, включая информацию о владельцах, а grep извлекает все пункты, содержащие строку **edk**.

**Конвейеры** — это возможность нескольких программ работать совместно, когда выход одной программы непосредственно идет на вход другой без использования промежуточных временных файлов. Синтаксис:

команда1 | команда2

Выполняет команду1 используя её поток вывода как поток ввода при выполнении команды2, что равносильно использованию двух перенаправлений и временного файла:

команда1 > ВременныйФайл

команда2 < ВременныйФайл

rm ВременныйФайл

#### 14) Фоновые процессы: запуск, остановка, слежение. Приостановка и возобновление emacs

**Фоновой процесс** — это процесс, который работает в фоне, на заднем плане. Имеется в виду, что оболочка операционной системы, которая выполняет фоновый процесс, не ждёт завершения или окончания процесса, как это происходит с обычными программами. Оболочка может запустить ещё много процессов сразу после запуска одного фонового так, что они будут выполняться одновременно._

_Типичными фоновыми процессами, выполняющимися в системе, являются обработчики событий и системные службы._

_Оболочка ОС UNIX подразделяет запущенные ей группы процессов на «переднего плана», «фоновые» и «приостановленные», и поддерживает перевод групп процессов из одного из выше названных классов в другой. Для этого используется & (амперсенд) в конце командной строки, клавиатурная комбинация Ctrl-Z (приостанавливает текущую группу процессов переднего плана), и команды jobs, fg (переносит описанное задание на передний план и делает его текущим) и bg (размещает описанное задания на заднем плане)._

_Обычно для вызова Emacs достаточно просто набрать `emacs' в оболочке. Если запускать Emacs из окна с оболочкой в системе X Windows, следует запускать его в фоновом режиме с помощью `emacs&'. Тогда Emacs не свяжет окно оболочки, что позволит выполнять другие команды, пока Emacs работает в своих X-окнах._

_Приостановка означает временную остановку Emacs и возврат управления его родительскому процессу (обычно это оболочка), она позволяет позднее возобновить редактирование в том же задании Emacs. Чтобы приостановить Emacs, следует набрать C-z (suspend-emacs). Это вернет пользователя обратно в оболочку, из которой вызывали Emacs. Можно возобновить Emacs с помощью команды `%еmacs' в большинстве обычных оболочек._

#### 15) Понятие о программировании на ИКЯ

Bourne-shell является наиболее распространенным командным языком (и одновременно командным интерпретатором) системы UNIX. Вот основные определения языка Bourne-shell (конечно, мы приводим неформальные определения, хотя язык обладает вполне формализованным синтаксисом):

_**Пробел** - это либо символ пробела, либо символ горизонтальной табуляции._

_**Имя** - это последовательность букв, цифр или символов подчеркивания, начинающаяся с буквы или подчеркивания._

_**Параметр** - имя, цифра или один из символов *, @, #, ?, -, $, !._

_**Простая команда** - последовательность слов, разделенных пробелами. Первое слово простой команды - это ее имя, остальные слова - аргументы команды (имя команды считается ее нулевым аргументом - см. п. 5.2.1)._

_**Метасимволы**. Аргументы команды (которые обычно задают имена файлов) могут содержать специальные символы (метасимволы) "*", "?", а также заключенные в квадратные скобки списки или указанные диапазоны символов. В этом случае заданное текстовое представление параметра называется шаблоном. Указание звездочки означает, что вместо указанного шаблона может использоваться любое имя, в котором звездочка заменена на произвольную текстовую строку. Задание в шаблоне вопросительного знака означает, что в соответствующей позиции может использоваться любой допустимый символ. Наконец, при использовании в шаблоне квадратных скобок для генерации имени используются все указанные в квадратных скобках символы. Команда применяется в цикле для всех осмысленных сгенерированных имен. Метасимволы – символы, порождающие другие_

_**Значение простой команды** - это код ее завершения, если команда заканчивается нормально, либо 128 + код ошибки, если завершение команды не нормальное (все значения выдаются в текстовом виде)._

_**Команда** - это либо простая команда, либо одна из управляющих конструкций (специальных встроенных в язык конструкций, предназначенных для организации сложных shell-программ)._

_**Командная строка** - текстовая строка на языке shell._

_**shell-процедура (shell-script)** - файл с программой, написанной на языке shell._

_**Конвейер** - последовательность команд, разделенных символом "|". При выполнении конвейера стандартный вывод каждой команды конвейера, кроме последней, направляется на стандартный вход следующей команды. Интерпретатор shell ожидает завершения последней команды конвейера. Код завершения последней команды считается кодом завершения всего конвейера._

_**Список** - последовательность нескольких конвейеров, соединенных символами ";", "&", "&&", "||", и, может быть, заканчивающаяся символами ";" или "&". Разделитель между конвейерами ";" означает, что требуется последовательное выполнение конвейеров; "&" означает, что конвейеры могут выполняться параллельно. Использование в качестве разделителя символов "&&" (и "||") означает, что следующий конвейер будет выполняться только в том случае, если предыдущий конвейер завершился с кодом завершения "0" (т.е. абсолютно нормально). При организации списка символы ";" и "&" имеют одинаковые приоритеты, меньшие, чем у разделителей "&&" и "||"._

_В любой точке программы может быть объявлена (и установлена) **переменная** с помощью конструкции "имя = значение" (все значения переменных - текстовые). Использование конструкций $имя или ${имя} приводит к подстановке текущего значения переменной в соответствующее слово._

_Предопределенными переменными Bourne-shell, среди прочих, являются следующие:_
- **HOME** - полное имя домашнего каталога текущего пользователя;
- **PATH** - список имен каталогов, в которых производится поиск команды, при ее указании коротким именем;
- **PS1** - основное приглашение shell ко вводу команды; и т.д.

#### Редактирование текстов

###### 1) Понятие о редакторе текстов. Основные типы редакторов

Для работы с текстами на компьютере используются программные средства, называемые текстовыми редакторами. Существует большое количество разнообразных текстовых редакторов, различающихся по своим возможностям Основное назначение текстовых редакторов – создавать текстовые файлы, редактировать тексты, просматривать их на экране, изменять формат текстового документа, распечатывать его на принтере. MS-DOS Editor и Блокнот предназначены для обработки несложных текстовых файлов Современные программы предусматривают множество дополнительных функций, позволяющих готовить текстовую часть документа на типографском уровне:

- форматирование символов и абзацев,
- оформление страниц,
- построение оглавлений и указателей,
- создание таблиц, проверка правописания и т. д.

Кроме того, современные программы позволяют включать в текст графические объекты: рисунки, диаграммы, фотографии.

**Современный текстовый процессор Microsoft Word** предназначен для создания, просмотра, модификации и печати текстовых документов, предусматривает выполнение операций над текстовой и графической информацией. С помощью Word можно быстро и с высоким качеством подготовить любой документ — от простой записки до оригинал-макета сложного издания.

Типы редакторов текстов:
- строчный процессор
- экранный процессор
- графический процессор
- пакетный процессор
- текстовый процессор

###### 3) Экранное редактирование. Концепция. Примеры экранных редакторов UNIX (vi, vim, emacs, ted)  

К экранному редактору вы можете получить доступ с помощью команды vi. Экранный редактор vi является дисплей-ориентированным, интерактивным программным средством. Он позволяет вам обозревать файл при редактировании постранично. Этот редактор работает наиболее эффективно на видеотерминалах, оперирующих со скоростью 1200 бод и выше.  

Вы можете модифицировать (добавлять, удалять, изменять) файл, позиционируя курсор в том месте на экране, где должны быть произведены изменения. Экранный редактор немедленно отображает результат изменений.

Экранный редактор предлагает вам набор команд. Например, команда number позволяет вам перемещать курсор внутри файла. Другие команды прокручивают вперед и назад файл на экране, помогают изменить существующий текст или создать новый текст. Дополнительно к своему набору команд экранный редактор может иметь доступ к командам построчного редактора. В табл. 6 приведены характеристики редакторов ed и vi.  

Редактор vi является мощным средством для создания и редактирования файлов. Он предназначен для работы на видеотерминале и использует окна, посредством которых вы можете просматривать текст файла. Несколько простых команд позволяют вам сделать изменения в тексте, которые очень быстро отображаются на экране. Редактор может отобразить одну или несколько строк текста. Он позволяет вам передвигать курсор в любую точку на экране или в файле, создавать, изменять или удалять текст. Вы можете также использовать некоторые команды построчного редактора, такие как глобальные команды, которые позволяют вам изменять множество появлений некоторой строки символов, используя одну команду. Чтобы двигаться по файлу, вы можете прокручивать текст вперед или назад.  
Примечание. Не все терминалы обладают способностью прокрутки текста и поэтому средство прокрутки текста редактором vi зависит от типа используемого терминала.  
Редактор vi имеет более 100 команд. В этом разделе описаны основные команды, которые позволят вам использовать vi просто, но эффективно. Особое внимание будет уделено выполнению следующих задач, позволяющих:  

- изменить окружение shell, чтобы установить конфигурацию вашего терминала;  
- сделать доступным автоматический возврат каретки;  
- начать работу с редактором vi, создать текст, исправить ошибки, записать текст в файл и  завершить работу;  
- переместить текст внутри файла;  
- разбить и слить текст;  
- использовать специальные команды и сокращения;  
- использовать команды построчного редактора, доступные внутри vi;  
- временно вернуться в shell, чтобы выполнить команды shell;  
- восстановить файл, потерянный из-за прерывания сессии редактирования;  
- редактировать несколько файлов в одной сессии.  

Vi называется экранным редактором, поскольку использует в качестве рабочего поля весь экран терминала, а не одну строку, как ed. Экран задействован большей частью для отображения редактируемого текста, а одну строку – последнюю – vi отводит для общения с пользователем в стиле ed. Помимо понятия текущей строки в vi появляется текущая позиция в строке, указателем на которую работает курсор (между прочим, до курсора создатели терминалов тоже додумались не сразу: ведь в пишущих машинках его не было). Все команды vi применяются к тексту именно в том месте, где находится курсор. Все это так похоже на устройство многих современных текстовых редакторов, что в объяснении не нуждается.

###### 5) GNU Emacs для работы с разными языками использует MULE (Многоязыковые расширения для GNU Emacs). Это позволяет эффективно работать как с европейскими, так и с азиатскими языками.  

Для работы с конкретным языком необходимо определить так называемое языковое окружение. Для ввода не-ASCII символов надо определить метод ввода. Для переключения между языками используется специальное сочетание клавиш C-\\.  
  
Чтобы настроить GNU Emacs для работы с русским языком (предполагается использование кодировки koi8-r), надо поместить в ваш файл настройки (~/.emacs) следующие строки:  
  
```bash
(set-language-environment 'Cyrillic-KOI8)  
(set-terminal-coding-system 'koi8-r)  
(set-keyboard-coding-system 'koi8-r)  
(setq default-buffer-file-coding-system 'koi8-r)  
(prefer-coding-system 'koi8-r)  
(define-coding-system-alias 'koi8-u 'koi8-r)  
(put-charset-property 'cyrillic-iso8859-5 'preferred-coding-system 'koi8-r)  
(codepage-setup 1251)  
(define-coding-system-alias 'windows-1251 'cp1251)  
(set-input-mode nil nil 'We-will-use-eighth-bit-of-input-byte)  
(setq-default coding-system-for-read 'koi8-r)  
(set-selection-coding-system 'koi8-r)  
```
  
Этот код устанавливает кодировку KOI8-R в качестве основной кодировки для чтения, записи и общения с внешними программами. Кроме этого, определяется псевдоним для русской кодировки Windows — **cp1251**.  
  
Для правильного отображения текстов необходимо установить для начертания default (это можно сделать с помощью команды M-x customize-face) шрифт, который содержит большой набор кодировок, включая кодировку для отображения UTF-8 (например, misc-fixed). Такая настройка позволит, например, нормально работать с русскими и немецкими словарями в одном буфере Emacs.

###### 7. Перемещение в буфере

![https://sun9-58.userapi.com/IHh4p2RJFJs9wDaYxmB17r7En-80AOYPH-6xEg/bxj1Sa_qJMY.jpg](file:///C:/Users/zakre/AppData/Local/Packages/oice_16_974fa576_32c1d314_2b4a/AC/Temp/msohtmlclip1/01/clip_image007.jpg)

###### 8. Команды для работы с текстом

![https://sun9-47.userapi.com/oive8rP-OUzcWHC2phBpwCc9jsViVrN95S2Nfg/TDQQlWZWqak.jpg](file:///C:/Users/zakre/AppData/Local/Packages/oice_16_974fa576_32c1d314_2b4a/AC/Temp/msohtmlclip1/01/clip_image009.jpg)

###### 9. Команды работы с пометками и регионами

![https://sun9-40.userapi.com/xpI0KSGh_u1acD-l4UQZpFs4TlHTMG2dwYlWLg/EwBf-IBr9Ac.jpg](file:///C:/Users/zakre/AppData/Local/Packages/oice_16_974fa576_32c1d314_2b4a/AC/Temp/msohtmlclip1/01/clip_image011.jpg)

Точка вставки (point) — это место в буфере, в котором происходит вставка или удаление данных. Считается, что точка вставки находится между двумя знаками, а не на каком-то одном из них. Например, если курсор находится на букве "h" в слове "the", то точка вставки находится между "t" и "h". Курсор терминала показывает положение точки вставки.  
  
Как и другие современные редакторы, Emacs позволяет выполнять разные действия над фрагментами текущего буфера — изменение отступа, проверку орфографии, переформатирование, вырезание, копирование, вставку и т.д. Вы можете подсветить (или "пометить") блок текста, используя клавиатуру или мышь, а затем выполнить операцию только над выделенным блоком. В Emacs такой блок текста называется область (region). Область — это текст между точкой и меткой.  
  
Метка указывает на позицию в тексте. Она определяет один конец области, в то время как точка вставки находится на другом конце области. Многие команды работают с текстом целиком от точки вставки до метки. Каждый буфер имеет свою метку.

###### 10) Команды поиска и замены

![https://sun9-39.userapi.com/2Ldn2FMI3ZOoKLsKIsXQlipP_6JjCmy1J49NCA/iO9lg0-NhbY.jpg](file:///C:/Users/zakre/AppData/Local/Packages/oice_16_974fa576_32c1d314_2b4a/AC/Temp/msohtmlclip1/01/clip_image012.jpg)

###### 11-12) Буфер и Окна
  
**Буфер** — это основная единица редактирования; один буфер соответствует одному куску редактируемого текста. Вы можете иметь несколько буферов, но в каждый конкретный момент вы редактируете только один выбранный буфер. При этом, разумеется, если вы используете несколько окон, то видимыми могут быть несколько буферов. Чаще всего буферы обращаются к какому-либо файлу, считывая данные из файла в буфер, или записывая данные из буфера в файл.  
  
Вы встретите термин "буфер" в документации по Emacs, сообщениях программы, описаниях режимов и пакетов. Просто имейте в виду, что при работе с файлами буфер означает "копию файла, которая находится в памяти в данный момент". Однако необходимо отметить, что буфер не всегда соответствует какому-либо файлу на диске. Очень часто Emacs создаёт буферы в результате выполнения ваших команд. Такие буферы могут содержать вывод команды, список для выбора вариантов и другую информацию.  
  
**Окно** в Emacs — это область экрана, в которой отображается буфер. Когда Emacs запускается, у вас на экране отображается одно окно. При обращении к некоторым функциям Emacs (таким, как оперативная справка и интерактивная документация) часто (временно) открываются дополнительные окна на экране Emacs.  
  
**Окна** Emacs не имеют ничего общего с окнами графической среды X Window. Одно окно X Window может быть разбито на несколько окон в смысле Emacs, в каждом из которых отображается отдельный буфер. Однако вы можете открывать для отображения буферов Emacs и дополнительные окна X, например, при сравнении двух файлов. Эти новые окна X в жаргоне Emacs называются фреймами.  
  
**Фрейм** (frame) — это отдельное окно используемой оконной системы, в котором отображаются одно или несколько окон Emacs. При этом несколько фреймов, открытых одновременно, являются частью одного сеанса Emacs.
  
![https://sun9-9.userapi.com/uz3q8uCbTEwApV0ptwV9NT9vw7TyXmlqjjFlKg/tb3lWxZ1QDI.jpg](file:///C:/Users/zakre/AppData/Local/Packages/oice_16_974fa576_32c1d314_2b4a/AC/Temp/msohtmlclip1/01/clip_image014.jpg)

**13**. Команды

Вы можете выполнять команды командного процессора прямо из GNU Emacs. Для выполнения одной команды вы можете использовать последовательность клавиш M-!, при этом результат выполнения отображается в мини-буфере. Но если вы хотите выполнить несколько команд с удобным просмотром результатов выполнения, то лучше использовать команду M-x shell (ESC + x и снизу написать shell) 